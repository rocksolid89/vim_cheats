глава 6. Глобальная замена ( продолжаем изучение )

замена текста в файле делается в помощью команды :s(substitute)
	:s/old/new - заменит в строке первое вхождение old на new
	:s/old/new/g - сделает тоже самое, но только в рамках целой строки (используя опцию g)
	:1,$s/old/new/g - сделает замену в целом файле (вместо 1,$ можно использовать %)

замена с подтверждением
	:s/old/new/gc - попросит подтвердить операцию замены на каждом вхождении "old" в строке
	--так же стоить заметить, что можно комбинировать команды поиска, замены слова (cw), повтора поиска и повтора выполнения последнего действия. Все это поможет контролировать процедуру
	глобальной замены. (/pattern; cwpattern_new; n ; .)


Замена, зависящая от контента:
	:g/pattern/s/old/new/g - глобальный поиск по файлу. в строке, в которой встречается pattern, прозводится глобальная замена old на new
	
	:g/pattern/s//new/g
	:%s/pattern/new/g	- эти две строки выполнят эквивалентные действия

Поиск по шаблону:
метасимволы (метапоследовательности) используемые в тестовых редакторах vi, ex:
. - означает любой символ, отличный от перевода строки
* - повторение любое количество раз символа (в том числе и пустого) стоящего перед символом *
^ - как правило обозначает начало строки ( если используется в середине регулярного выражения - то означает сам себя - т.е. знак каретки)
	к тому же если этот символ используется в скобках [^0-9] - соответствие любому символу не из списка :)
$ - конец строки
\ - escape character
[] - соответствует любому символу, указанному в скобках; например [0-9] - соответствует любой цифре от 0-9
\( \) - сохраняет шаблон в специальном буфере (hold buffer); которые в дальнейшем можно вызвать с помощью команд \1 \9 ( всего 9 буферов )
	42s/\(first\) or \(second\)/\2 or \1/ - в сорок второй строке поменяет местами слова second и first
\< \> - обозначают начало и конец слова соотвественно
	\<ac - все слова в начале которых есть буквы ac
	ac\> - все слова в конце которых есть буквы ac
~ - соответствует регулярному выражению, которое использовалось в последний раз (сомнительная опция для vi)

выражения в скобках в стандарте POSIX(portable operating system interface for UNIX)

вводит дополнительные функциональные возможности для обработки символов из разных алфавитов
	bracket expressions - группа символов в скобках
[::] - классы символов
[..] - объединенные символы
[==] - классы эквивалентности

использование метасимволов в строках замены

данные символы несут в себе функциональное значение только в том случае, если использутся в первой части (т.е. в шаблоне по которому ведется поиск)

:s/1\. Start/ 2. finish $$$/ - вторая часть будет обработана и корректно записана в файл


#метасимволы в строке замены

\n - вставка одного из hold buffers (1-9)
\ - предназначена для экранирования (написанный символ рассматривается как обычный)
& - заменяет на весь текст, соответствующий строке поиска
	%/s/james/&, pavel/ - заменит james наjames, pavel
	например, чтобы закомментировать диапазон строк можно использовать следующий шаблон поиска
	1,10s/.*/# &/
~ - найденная строка заменяется на текст, используемый в последней команде подстановки :)
	s/thiet/their
	s/adf/~ - поменяет adf на their (корый использовался в предыдущей команде поиска и замены) 

\u - меняет регистр первой буквы в слове на заглавный
\l - меняет регистр первой буквы в слове на прописной
	:s/\(First\) or \(second\)/\u\2 or \l\1/ - поменяет все на Second or First 


\U - действует до конца строки замены **
\L - lowercase до конца строки замены

	:s/Fortran/\U& - заменит Fortran на FORTAN

##########Continue

некоторые трюки при работе с заменами


--в качестве разделителя мы можем использовать любые символы, отличныые от \ " |
	например для замены имен файлов можно использовать следующую команду замены
	:%s;/dev/sda1;/dev/sda2;g - поменяет имя используемого в системе жесткого диска во всем файле
-- :s равносильно выполнению следующей команды: s//~/ #повторение предыдущей замены.
-- :set edcompatible - запоминает флаги команды поиска /g /c использует их при других заменах 
-- & (:&) - работает как выполнение последней замены в тексте.
--:s/\<child\>/children/ - данная команда поменяет слово (но не затронет другие слова, содержашие в себе часть этого)

--нужно заменить во всех строках файла текст типо proc1_class; proc2_class на proc1_function; proc2_function
	:g/proc\([123]\)_class/s//proc\1_function/g
